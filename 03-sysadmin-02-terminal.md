# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

## 1. Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.   
     
  Команда cd относится к встроенным командам оболочки и без неё работать не может. Она не является самостоятельной программой и не может выполняться отдельно.
      
   Теоретически можно сделать CD внешней программой, но после смены директории необходимо вызвать bash из этого каталога, но тогда мы получим новый shell. И выходя из сессии придется выходить, опять же, из всех сессий, которые создали при каждом вызове внешней CD.
    
## 2.  Какая альтернатива без pipe команде  `grep <some_string> <some_file> | wc -l`?  `man grep`  поможет в ответе на этот вопрос. Ознакомьтесь с  [документом](http://www.smallo.ruhr.de/award.html)  о других подобных некорректных вариантах использования pipe.
  
  Поиск по `man wc -l` выдал информацию, что данная команда, с атрибутом `-l`, используется для вывода количества вхождений того, что мы передаём в strout grep-а. У grep есть собственный параметр, отвечающий за аналогичный вывод `-c`.
    **vagrant@vagrant**:**~**$ cat test_bash
    if [[ -d /tmp ]];
    hgfghdfgh
    fhfgyuhfght
    123
    **vagrant@vagrant**:**~**$ grep 123 test_bash -c
    1
    **vagrant@vagrant**:**~**$ grep 123 test_bash |wc -l
    1
    
## 3. Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
  
  Выполним `pstree -p` и получим результат systemd(1)
    **vagrant@vagrant:~**$ pstree -p 
    systemd(1)─┬─VBoxService(758)─┬─{VBoxService}(760)
            
## 4. Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?

`ls /non_existing_folder 2> /dev/pts/#`  
stderr имеет параметр 2, поэтому нам необходимо имитировать ошибку. В примере мы пытаемся посмотреть содержимое несуществующей директории (получаем ошибку для вывода) и перенаправляем вывод на другую сессию `/dev/pts/номер`. Номер сессии можно узнать, используя команду `who`.
    

## 5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.

`less < original_file > new_file`  
Мы перехватываем ввод (stdin)  `less`  у исходного файла и перенаправляем в новый.

## 6. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
   
   Вывести получится при использовании перенаправления вывода:
**evgeniy@evgeniy-ms7788**:~$ tty
/dev/pts/0
**evgeniy@evgeniy-ms7788**:~$ echo Hello from pts0 to tty3 >/dev/tty3
**evgeniy@evgeniy-ms7788**:~$  
     но наблюдать в графическом режиме не получиться, нужно переключиться в контекст TTY : Выводом будет Hello from pts0 to tty3
 
 Так же можно перенаправить контекст из tty в pty, этот вывод можно наблюдать  после возврата в графический режим:
           
## 7. Выполните команду  `bash 5>&1`. К чему она приведет? Что будет, если вы выполните  `echo netology > /proc/$$/fd/5`? Почему так происходит?

`bash 5>&1`  - Создаст дескриптор 5 и перенаправит его в stdout  
`echo netology > /proc/$$/fd/5`  - выведет дескриптор 5, который был перенаправлен в stdout
      
если запустить  `echo netology > /proc/$$/fd/5`  в новой сессии, получим ошибку, так как такого дескриптора, в данный момент, в текущей (новой) сессии - нет.  
    
## 8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от  `|`  на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

Воспользуемся потоком 5, созданным в предыдущем задании. Перенаправим вывод следующим образом: в поток 5 мы перенаправляем `stdout`, `stdin` перенаправляем в `stderr`, а `stderr` в вновь созданный поток 5. Если мы вызовем какую-нибудь ошибку > результат (stderr) будет записан в файл, при этом мы получим отображение ошибки на экране :

**evgeniy@evgeniy-ms7788:**~$ toor 5>&1 1>&2 2>&5 | tee test.txt
bash: toor: команда не найдена  
        
## 9. Что выведет команда  `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?
   Будут выведет данные окружения `env`
   Можно получить тоже самое только с разделением по переменным по строкам:
    `printenv`
    `env`
    
## 10. Используя  `man`, опишите что доступно по адресам  `/proc/<PID>/cmdline`,  `/proc/<PID>/exe`.

В `/proc/<PID>/cmdline` находится командная строка, вызывающая процесс `<PID>` процесс. В `/proc/<PID>/exe` содержится символьная ссылка на исполняемый файл, который запустил процесс.

## 11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью  `/proc/cpuinfo`.
 
  **vagrant@vagrant**:**~**$ grep sse /proc/cpuinfo
 sse4_2
    
## 12. При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2.
Однако:
    vagrant@netology1:~$ ssh localhost 'tty'
    not a tty
 Почитайте, почему так происходит, и как изменить поведение.
 
Нет локального tty в данный момент. 
для запуска можно добавить -t  , и команда исполняется c принудительным созданием псевдотерминала с созданием SHAkey
    
**vagrant@vagrant**:**~**$ ssh -t localhost 'tty'
    vagrant@localhost's password: 
    /dev/pts/0
    Connection to localhost closed.
    **vagrant@vagrant**:**~**$ 
    
## 13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись  `reptyr`. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.

Допустим хотим загрузить какой-то  образ `wget http://чегото-там` и вдруг поняли что это обычный SSH сеанс. Не беда. `Reptyr` поможет нам переместить запущенные процессы между pty. Достаточно знать PID процесса. Выполнив `reptyr -T <PID>` переместим процесс в нужную сессию.
    
## 14.  `sudo echo string > /root/new_file`  не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без  `sudo`  под вашим пользователем. Для решения данной проблемы можно использовать конструкцию  `echo string | sudo tee /root/new_file`. Узнайте что делает команда  `tee`  и почему в отличие от  `sudo echo`  команда с  `sudo tee`  будет работать.

`tee` используется для перенаправления потока ввода в вывод. Команда не является встроенной в оболочку bash, которая запускается при старте системы, поэтому для её работы root-прав не требуется.
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTY3OTc3NjUyOCwxOTQ0NzcxODY1LC0xOD
YwMjI5MzMxLC0xODc5Njg3OTMsLTIxMTg4MDA2NiwtMTAyNDk2
NzExMSwzOTA1NTU5NTMsLTQ0NzIwMDQ2MiwxMjUyNDIyMTY4LC
05ODQzMDIxMTcsLTE4ODUwMTkyODQsLTY2NzI3MTcxOSwyMDg4
Njg4MDkyLDIwMDQ5NjU1OTYsMTA4NjU3OTEzNiw5ODg3NjE3MT
MsLTEzNjY4ODE4NDAsLTE0MjAxMDAzMDMsLTE2MzMxMzQyMiwz
ODIzOTA1MThdfQ==
-->